[TOC]

## Summary

This article is for intermediate readers. It relates to the following ideas:
Pop Count, Most Significant Bit, Least Significant Bit, Last Set Bit and Dynamic Programming.

## Solutions

---

#### Approach 1: Pop Count

**Intuition**

Solve the problem for one number at a time.

**Algorithm**

This problem can be seen as a follow-up of the [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/), where we need to count the bits for an unsigned integer. The number is often called pop count or [Hamming weight](https://en.wikipedia.org/wiki/Hamming_weight). See the editorial of [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/) for a detailed explanation of different approaches.

Now we just take that for granted. And suppose we have the function `int popCount(int x)` which will return the count of the bits for a given non-negative integer. We just loop through the numbers in the range `[0, n]` and put the results in a list.

**Implementation**

<iframe src="https://leetcode.com/playground/ZR7fwK5M/shared" frameBorder="0" width="100%" height="344" name="ZR7fwK5M"></iframe>

**Complexity Analysis**

* Time complexity: $O(n \cdot \log n)$. For each integer $x$, in the worst case, we need to perform $O(\log n)$ operations, since the number of bits in $x$ equals to $\log x + 1$ and all the bits can be equal to $1$. However, on average, each bit will be set $n / 2$ times, so for each integer $x$ we will perform $\log (x) / 2$ operations, therefore, in total, it will cost $O(n \cdot \log (n) / 2)$ operations.

* Space complexity: $O(1)$. Since the output array does not count towards the space complexity.

----

#### Approach 2: DP + Most Significant Bit

**Intuition**

Use previous count results to generate the count for a new integer.

**Algorithm**

Suppose we have an integer:

$$
x = (1001011101)_2 = (605)_{10}
$$

and we already calculated and stored all the results of $0$ to $x - 1$.

Then we know that $x$ is differ by one bit with a number we already calculated:

$$
x' = (1011101)_2 = (93)_{10}
$$

They are different only in the most significant bit.

Let's examine the range $[0, 3]$ in the binary form:

$$
(0) = (0)_2
$$

$$
(1) = (1)_2
$$

$$
(2) = (10)_2
$$

$$
(3) = (11)_2
$$

One can see that the binary form of 2 and 3 can be generated by adding 1 bit in front of 0 and 1. Thus, they are different only by 1 regarding pop count.

Similarly, we can generate the results for $[4, 7]$ using $[0, 3]$ as blueprints.

In general, we have the following transition function for popcount $P(x)$:

$$
P(x + b) = P(x) + 1, b = 2^m > x
$$

With this transition function, we can then apply Dynamic Programming to generate all the pop counts starting from $0$.

**Implementation**

<iframe src="https://leetcode.com/playground/esiVrAyF/shared" frameBorder="0" width="100%" height="395" name="esiVrAyF"></iframe>

**Complexity Analysis**

* Time complexity: $O(n)$. For each integer $x$, in the range $1$ to $n$, we need to perform a constant number of operations which does not depend on the number of bits in $x$.

* Space complexity: $O(1)$. Since the output array does not count towards the space complexity.

---

#### Approach 3: DP + Least Significant Bit

**Intuition**

We can have different transition functions, as long as $x'$ is smaller than $x$ and their pop counts have a function.

**Algorithm**

Following the same principle of the previous approach, we can also have a transition function by playing with the least significant bit.

Let look at the relation between $x$ and $x' = x / 2$

$$
x = (1001011101)_2 = (605)_{10}
$$

$$
x' = (100101110)_2 = (302)_{10}
$$

We can see that $x'$ is differ than $x$ by one bit, because $x'$ can be considered as the result of removing the least significant bit of $x$.

Thus, we have the following transition function of pop count $P(x)$:

$$
P(x) = P(x / 2) + (x \mod 2)
$$

**Implementation**

<iframe src="https://leetcode.com/playground/7GjGnBXs/shared" frameBorder="0" width="100%" height="225" name="7GjGnBXs"></iframe>

**Complexity Analysis**

* Time complexity: $O(n)$. For each integer $x$, in the range $1$ to $n$, we need to perform a constant number of operations which does not depend on the number of bits in $x$.

* Space complexity: $O(1)$. Since the output array does not count towards the space complexity.

---

#### Approach 4: DP + Last Set Bit

**Algorithm**

With the same logic as previous approaches, we can also manipulate the last set bit.

Last set bit is the rightmost set bit. Setting that bit to zero with the bit trick, `x &= x - 1`, leads to the following transition function:

$$
P(x) = P(x \mathrel{\&} (x - 1)) + 1
$$

**Implementation**

<iframe src="https://leetcode.com/playground/EDe6PbEm/shared" frameBorder="0" width="100%" height="208" name="EDe6PbEm"></iframe>

**Complexity Analysis**

* Time complexity: $O(n)$. For each integer $x$, in the range $1$ to $n$, we need to perform a constant number of operations which does not depend on the number of bits in $x$.

* Space complexity: $O(1)$. Since the output array does not count towards the space complexity.

