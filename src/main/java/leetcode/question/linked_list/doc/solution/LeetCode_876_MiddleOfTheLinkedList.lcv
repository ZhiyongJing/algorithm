[TOC]

## Video Solution

---

<div> 
 <div class="video-container"> 
  <iframe src="https://player.vimeo.com/video/740843099?texttrack=en-x-autogenerated" frameborder="0" allow="autoplay; fullscreen"></iframe> 
 </div> 
</div>

## Solution Article

---

#### Approach 1: Output to Array

**Intuition and Algorithm**

Put every node into an array `A` in order.  Then the middle node is just `A[A.length // 2]`, since we can retrieve each node by index.

We can initialize the array to be of length `100`, as we're told in the problem description that the input contains between `1` and `100` nodes.

<iframe src="https://leetcode.com/playground/FxMEQfWD/shared" frameBorder="0" width="100%" height="242" name="FxMEQfWD"></iframe>

**Complexity Analysis**

* Time Complexity:  $O(N)$, where $N$ is the number of nodes in the given list.

* Space Complexity:  $O(N)$, the space used by `A`.

<br />

---

#### Approach 2: Fast and Slow Pointer

**Intuition and Algorithm**

When traversing the list with a pointer `slow`, make another pointer `fast` that traverses twice as fast.  When `fast` reaches the end of the list, `slow` must be in the middle.

<iframe src="https://leetcode.com/playground/5RXifTh4/shared" frameBorder="0" width="100%" height="259" name="5RXifTh4"></iframe>

**Complexity Analysis**

* Time Complexity:  $O(N)$, where $N$ is the number of nodes in the given list.

* Space Complexity:  $O(1)$, the space used by `slow` and `fast`.

<br /> 
<br />

