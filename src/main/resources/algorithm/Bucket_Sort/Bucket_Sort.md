# 1. Quick Selection 算法思想

> 前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。
>
> 桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。


# 2. 算法适用场景

> 桶排序适用于**处理体量很大的数据**。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。 
>
> - 时间复杂度：O(N + K)
>
>   > 假设元素在各个桶内平均分布，那么每个桶内的元素数量为N/K. 假设排序单个桶使用 **O(N/K * logN/K) **时间，则排序所有桶使用**O(N * logN/K)**时间。当桶数量 K 比较大时，时间复杂度则趋向于 O(N) 。合并结果时需要遍历所有桶和元素，花费 O(N + K)时间。在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 O(N^2)时间。
>
> - 空间复杂度：O( N + K) , **非原地排序**：需要借助 个桶和总共 个元素的额外空间。
>
> - 桶排序是否稳定取决于排序桶内元素的算法是否稳定。
>
> 

# 3. 算法模版

## 3.1 非递归方式实现

> 考虑一个长度为 的数组，其元素是范围 内的浮点数。桶排序的流程如图所示。
>
> 1. 初始化k 个桶，将 n个元素分配到 个桶中。
> 2. 对每个桶分别执行排序（这里采用编程语言的内置排序函数）。
> 3. 按照桶从小到大的顺序合并结果。
>
> [![桶排序算法流程](Bucket_Sort.assets/bucket_sort_overview.png)](https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/bucket_sort_overview.png)

~~~java
/* 桶排序 */
void bucketSort(float[] nums) {
    // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素
    int k = nums.length / 2;
    List<List<Float>> buckets = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        buckets.add(new ArrayList<>());
    }
    // 1. 将数组元素分配到各个桶中
    for (float num : nums) {
        // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]
        int i = (int) (num * k);
        // 将 num 添加进桶 i
        buckets.get(i).add(num);
    }
    // 2. 对各个桶执行排序
    for (List<Float> bucket : buckets) {
        // 使用内置排序函数，也可以替换成其他排序算法
        Collections.sort(bucket);
    }
    // 3. 遍历桶合并结果
    int i = 0;
    for (List<Float> bucket : buckets) {
        for (float num : bucket) {
            nums[i++] = num;
        }
    }
}
~~~



# 4. 时间复杂度

> - 时间复杂度：O(N + K)
>
>   > 假设元素在各个桶内平均分布，那么每个桶内的元素数量为N/K. 假设排序单个桶使用 **O(N/K * logN/K) **时间，则排序所有桶使用**O(N * logN/K)**时间。当桶数量 K 比较大时，时间复杂度则趋向于 O(N) 。合并结果时需要遍历所有桶和元素，花费 O(N + K)时间。在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 O(N^2)时间。
>
> - 空间复杂度：O( N + K) , **非原地排序**：需要借助 个桶和总共 个元素的额外空间。