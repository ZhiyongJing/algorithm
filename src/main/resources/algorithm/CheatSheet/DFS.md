深度优先搜索 DFS

## 使用条件

- 找满足某个条件的所有方案（99%）
- 二叉树 `Binary Tree` 的问题（90%）
- 组合问题（95%）
  - 问题模型：求出所有满足条件的“组合”
  - 判断条件：组合中的元素是顺序无关的
- 排列问题（95%）
  - 问题模型：求出所有满足条件的“排列”
  - 判断条件：组合中的元素是顺序“相关”的

## 不要用 `DFS` 的场景

- 连通块问题（一定要用 `BFS`，否则 `StackOverflow`）
- 拓扑排序（一定要用 `BFS`，否则 `StackOverflow`）
- 一切 `BFS` 可以解决的问题

## 复杂度

- 时间复杂度：

  O(方案个数∗构造每个方案的时间)*O*(方案个数∗构造每个方案的时间)

  - 树的遍历 ：O(n)*O*(*n*)
  - 排列问题 ：O(n!∗n)*O*(*n*!∗*n*)
  - 组合问题 ：O(2n∗n)*O*(2*n*∗*n*)

## 代码模板

java

python

```java
1public ReturnType dfs(参数列表) {
2    if (递归出口) {
3        记录答案
4        return;
5    }
6    for (所有的拆解可能性) {
7        修改所有的参数
8        dfs(参数列表);
9        还原所有被修改过的参数
10    }
11    return something 如果需要的话，很多时候不需要 return 值除了分治的写法
12}
```