# 1. 算法思想

> - 动态规划对问题进行分解，并通过存储子问题的解来规避重复计算，提高 计算效率。
>
> - 不考虑时间的前提下，所有动态规划问题都可以用回溯（暴力搜索）进行求解，但递归树中存在大量的重叠子问题，效率极低。通过引入记忆化列表，可以存储所有计算过的子问题的解，从而保证重叠子问题只被计算一次。
>
> - 记忆化递归是一种从顶至底的递归式解法，而与之对应的动态规划是一种从底至顶的递推式解法，其如同“填写表格”一样。由于当前状态仅依赖某些局部状态，因此我们可以消除 表的一个维度，从而降低空间复杂度。
>
> - 子问题分解是一种通用的算法思路，在分治、动态规划、回溯中具有不同的性质。
>
> - 动态规划问题有三大特性：重叠子问题、最优子结构、无后效性。
>
> - 如果原问题的最优解可以从子问题的最优解构建得来，则它就具有最优子结构。
>
> - 无后效性指对于一个状态，其未来发展只与该状态有关，而与过去经历的所有状态无关。许多组合优化问题不具有无后效性，无法使用动态规划快速求解。
>
>   - 只记录子问题的结果：这是因为动态规划在求解问题的过程中，实际上需要解决原始问题的所有子问题。如果把这些子问题的求解过程都记录下来，不仅有空间消耗，还有时间消耗。所以使用动态规划解决的问题通常只需要记录子问题的结果。
>
>   
>
> - 动态规划（Dynamic Programming）和分治（Divide and Conquer）都是解决问题的常用算法范式，它们有一些相似之处，但也存在明显的区别。
>
>   - 相似之处：
>
>   1. **问题划分：** 在两者中，问题都被划分为一些子问题，这些子问题可以独立求解。
>   2. **递归求解：** 对子问题的解进行递归求解。
>
>   - 区别：
>
>   1. **子问题重叠性：**
>      - **动态规划：** 动态规划中，子问题通常具有重叠性，即相同的子问题可能会被多次求解。为了避免重复计算，动态规划使用一种记忆化的方式（例如使用数组或哈希表）来存储已经计算过的子问题的解。
>      - **分治：** 分治通常不要求子问题有重叠性，因为分治每次都对问题进行完全划分，子问题之间没有共同的部分。
>   2. **最优子结构：**
>      - **动态规划：** 动态规划问题具有最优子结构性质，即全局最优解可以通过子问题的最优解来构建。
>      - **分治：** 分治问题可以没有最优子结构，即子问题的最优解并不一定能够直接构建全局最优解。
>   3. **问题求解方式：**
>      - **动态规划：** 动态规划通常采用自底向上的迭代方式，从最小的子问题开始逐步构建解。
>      - **分治：** 分治通常采用自顶向下的递归方式，将问题不断划分为子问题。
>   4. **时间复杂度：**
>      - **动态规划：** 动态规划常常具有较小的时间复杂度，因为它避免了重复计算。
>      - **分治：** 分治在不具备重叠子问题性质时可能导致较高的时间复杂度。

# 2 算法适用场景

> - 适用场景
>   - 最短路径问题、背包问题、字符串编辑距离等。
>   - 求最大值最小值
>   -  判断是否可行 
>   - 统计方案个数
> - 不适用场景
>   - 求出所有 具体 的方案而非方案 个数
>   - 输入数据是一个 集合 而不是 序列
>   - 动态规划擅长与优化指数级别复杂度(2^n,n!)到多项式级别复杂度(n^2,n^3)

# 3. 算法模版

> - 求解一个动态规划问题有两个不同的方向：自顶向下与自底向上
>
>   1. **「递推」是从「问题边界」开始的正向推导**， 即 **Divide And Conquer + 记忆化搜索(剪枝)**
>
>   > 自顶向下：我们在解决问题的时候 **对原问题进行拆分**。
>   >
>   > - 拆分成不同规模的子问题，再对每一个子问题进行拆分。直到它们不能够再拆分为止；
>   >
>   > - 由于不能再拆分了，最小规模的子问题不用求解直接得到答案。然后一步一步 **向上传递**，根据较小规模的子问题得到较大规模的子问题的结果，直到原问题得到了解决。
>   >
>   > 自顶向下这件事情其实我们一直都在做。在生活和工作中遇到的问题，我们会把解决它们的方案和结果记录到博客和笔记中，如果以后再遇到它们，就不用再解决一遍。
>   >
>   > 例如 Minimum Path Sum
>   >
>   > 
>
>   2. **「递归」是从原问题开始到「问题边界」的反向推导**。
>
>   > 自底向上与自顶向下最大的不同在于：自底向上没有「拆分问题」的过程。直接从一个问题最小的规模开始，一步一步通过「递推」的方式得到原问题的答案.
>   >
>   > 例如： 斐波那契数列
>   >
>   > ![image-20240107125727855](/Users/zhiyongjing/Repo/algorithm/src/main/resources/algorithm/DP.assets/1.png)
>   >
>   > 例如： 爬楼梯
>   >
>   > ![image-20240107125952753](/Users/zhiyongjing/Repo/algorithm/src/main/resources/algorithm/DP.assets/2.png)
>
> - 动规四要素
>
>   1. 定义状态 **State**：定义子问题
>
>   > 我们在拆分子问题的时候，会想到一个问题：**如何描述子问题**。而描述子问题这件事情就叫做 **定义状态**。
>   >
>   > 例如： 在 Minimum Path Sum中， state: `dp[i][j]`从起点走到 i, j 的最短路径
>   >
>   > ![image-20240107131303476](/Users/zhiyongjing/Repo/algorithm/src/main/resources/algorithm/DP.assets/3.png)
>
>   2. 推导状态转移方程 **Function**：描述不同规模子问题之间的关系
>
>   > 状态转移方程描述了不同规模子问题之间的关系。
>   >
>   > 由于求汇总值有这样的特点：**由小规模的问题的解可以得到大规模的问题的解**。
>   >
>   > 例如： 在 Minimum Path Sum中， state: `dp[i][j]= min(dp[i-1, j], dp[i, j-1]) + grid[i, j]`
>   >
>   > 例如： 在0-1背包问题中，`dp[i, c] = max(dp[i-1, c], dp[i-1, c - wgt[i-1]] + val[i-1])`
>   >
>   > - **不放入物品 i**：背包容量不变，状态变化为 dp[i-1, c] 。
>   >
>   > - **放入物品 i** ：前 i−1件物品放入剩下的容量为c - wgt[i-1]的背包中, 即`dp[i-1, c - wgt[i-1]] + val[i-1]`
>   >
>   >   
>   >
>   > ![image-20240107131925472](/Users/zhiyongjing/Repo/algorithm/src/main/resources/algorithm/DP.assets/4.png)
>   
>   3. 确定初始化 **Initialization** ， **边界条件** 和  **状态转移顺序**
>   
>   > 例如在 爬楼梯 问题中， 初始化 `dp[1] = 1, dp[2]=2`
>   >
>   > ![image-20240107132007819](/Users/zhiyongjing/Repo/algorithm/src/main/resources/algorithm/DP.assets/5.png)
>   
>   4. 答案 **Answer**
>
> 

## 3.1 从上往下实现通常使用递归和记忆化搜索

> - 记忆化递归是一种从顶至底的递归式解法

~~~java
//自顶向下
/* 最小路径和：记忆化搜索 */
int minPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) {
    // 若为左上角单元格，则终止搜索
    if (i == 0 && j == 0) {
        return grid[0][0];
    }
    // 若行列索引越界，则返回 +∞ 代价
    if (i < 0 || j < 0) {
        return Integer.MAX_VALUE;
    }
    // 若已有记录，则直接返回
    if (mem[i][j] != -1) {
        return mem[i][j];
    }
    // 左边和上边单元格的最小路径代价
    int up = minPathSumDFSMem(grid, mem, i - 1, j);
    int left = minPathSumDFSMem(grid, mem, i, j - 1);
    // 记录并返回左上角到 (i, j) 的最小路径代价
    mem[i][j] = Math.min(left, up) + grid[i][j];
    return mem[i][j];
}
~~~

## 3.2 从下往上通常通过迭代实现

> - 

    //自下往上
    /* 最小路径和：动态规划 */
    int minPathSumDP(int[][] grid) {
        int n = grid.length, m = grid[0].length;
        // 初始化 dp 表
        int[][] dp = new int[n][m];
        dp[0][0] = grid[0][0];
        // 状态转移：首行
        for (int j = 1; j < m; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        // 状态转移：首列
        for (int i = 1; i < n; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        // 状态转移：其余行和列
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
            }
        }
        return dp[n - 1][m - 1];
    }


# 4. 算法复杂度

> - 时间复杂度
> - 空间复杂度

不放入物品：

​	之前放过：`dp[i, c] = max(dp[i-1, c], dp[i - 1, c - wgt[i-1]] + val[i-1])`

​	之前没放过：`dp[i, c] = max(dp[i-1, c], dp[i - 1, c - wgt[i-1]] + val[i-1])`

放入物品：

​	之前放过：``

​	之前没放过：``
