# 1. 算法思想

> - 分治是一种常见的算法设计策略，包括分（划分）和治（合并）两个阶段，通常基于递归实现。
> - 判断是否是分治算法问题的依据包括：问题能否分解、子问题是否独立、子问题能否合并。
> - 归并排序是分治策略的典型应用，其递归地将数组划分为等长的两个子数组，直到只剩一个元素时开始逐层合并，从而完成排序。
> - 引入分治策略往往可以提升算法效率。一方面，分治策略减少了操作数量；另一方面，分治后有利于系统的并行优化。
> - 分治既可以解决许多算法问题，也广泛应用于数据结构与算法设计中，处处可见其身影。
> - 相较于暴力搜索，自适应搜索效率更高。时间复杂度为 的搜索算法通常是基于分治策略实现的。
> - 二分查找是分治策略的另一个典型应用，它不包含将子问题的解进行合并的步骤。我们可以通过递归分治实现二分查找。
> - 在构建二叉树的问题中，构建树（原问题）可以划分为构建左子树和右子树（子问题），这可以通过划分前序遍历和中序遍历的索引区间来实现。
> - 在汉诺塔问题中，一个规模为 的问题可以划分为两个规模为 的子问题和一个规模为 的子问题。按顺序解决这三个子问题后，原问题随之得到解决。

# 2 算法适用场景

> - 二分查询， 树的遍历
>
> - 一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。
>
>   1. **问题可以分解**：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。
>   2. **子问题是独立的**：子问题之间没有重叠，互不依赖，可以独立解决。
>   3. **子问题的解可以合并**：原问题的解通过合并子问题的解得来。
>
>   显然，归并排序满足以上三个判断依据。
>
>   1. **问题可以分解**：递归地将数组（原问题）划分为两个子数组（子问题）。
>   2. **子问题是独立的**：每个子数组都可以独立地进行排序（子问题可以独立进行求解）。
>   3. **子问题的解可以合并**：两个有序子数组（子问题的解）可以合并为一个有序数组（原问题的解）。

# 3. 算法模版

## 3.1 递归方式实现

> - merge sort
>
>   > **分**：递归地将原数组（原问题）划分为两个子数组（子问题），直到子数组只剩一个元素（最小子问题）。
>  >
>   > **治**：从底至顶地将有序的子数组（子问题的解）进行合并，从而得到有序的原数组（原问题的解）。
>
>   ![1](/Users/zhiyongjing/Repo/algorithm/src/main/resources/algorithm/Divide_And_Conquer.assets/1.png)

~~~java
public class DivideAndConquer {
    // 主函数，入口
    public static int divideAndConquer(int[] nums, int left, int right) {
        // 1. 判断递归结束条件
        if (left == right) {
            // 处理基本情况
            return nums[left];
        }

        // 2. 将问题分解为子问题
        int mid = (left + right) / 2;

        // 3. 递归求解子问题
        int leftResult = divideAndConquer(nums, left, mid);
        int rightResult = divideAndConquer(nums, mid + 1, right);

        // 4. 合并子问题的解
        int combinedResult = combineResults(leftResult, rightResult);

        return combinedResult;
    }

    // 辅助函数，用于合并子问题的解
    private static int combineResults(int left, int right) {
        // 根据具体问题合并子问题的解
        return Math.max(left, right);  // 以最大值为例
    }
}
~~~



# 4. 算法复杂度

> - 时间复杂度: O(logN), 剪枝情况下， O(N)
> - 空间复杂度: O(1)

