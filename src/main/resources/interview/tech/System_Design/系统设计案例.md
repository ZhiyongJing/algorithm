### 1. Tiny URL 

> **Functional requirement: **
>
> > - Given a URL, service will generate a unique and shorter url
> > - When user click on the shorter url, our service will return original URL and redirect to the original link
> > - Tiny URL will be expired within a time period
> > - User may be able to customized a short URL
> > - Deleter URL
>
> **Non-Function requeirment:**
>
> > - Availiblity: The system should be high availability, otherwise Tiny URL redirections will be failed
> > - Scalability: System can be horizontally scalable by following CAP theorem 
> > - Latency: Redirection should happen in real-tim with mimium latency 
> > - Tiny URL should not be predicatable 
> > - Read heavy service
>
> **Extended requirement:**
>
> > The service should be accessed through RESTful API. 
> >
> > - Based on senario of when, where, how it happens
> > - Based on how easy to implement the service
>
> **Capacity Estimation and Constraints**
>
> > how many users we have? 
> > Let’s assuem we have 200M users.  let’s suppose each user will  generate 0.1 URL per day， redirected by 10 URLs/day
> >
> > - Write QPS
> >   - Average: 200,000,000* 0.1 / (24*3600) = 231.4 QPS , Let’s say 200 QPS
> >   - Peak: 1000*2 = 400 QPS 
> > - Read QPS
> >   - Average: 20K QPS
> >   - Peak: 40K QPS
> > - Storage
> >   - 500 byte for every url, 200,000,000* 0.1* 0.5 KB= 10,000,000 KB = 10000 MB = 10 GB / DAY
> >   - 10 TB distk can use 3 years, if we store 5 years, we need 20TB including backup
> > - Memory
> >   - Let’s follow 8/2 rule, means 20% of URLs taking 80% traffic, and we can cache 20% URLs per day
> >   - Every day, we need 200M * 0.5 KB* 10 *0.2 = 200,000,000 KB = 200GB /DAY
>
> **Service:**
>
> > - Functions
> >
> >   - Create Tiny URL
> >     `createURL(APIKey, userId, originalURL, customize_alias = None, expire_data = 5 years)`
> >
> >     API key can prevent abuse, and 
> >
> >   - Return original URL
> >
> >     `redirectURL(userId, tinyURL)`
> >
> >   - Delete Tiny URL
> >
> >     `deleteURL(userId, tinyURL)`
> >
> > - RESTful API
> >
> >   - GET /<tiny_url>
> >   - POST /tiny_url
> >     - Payload: {……) 
> >     - Return: short url
> >
> > **How do we detect and prevent abuse?** 
> > For instance, any service can put us out of business by consuming all our keys in the current design. To prevent abuse, we can limit users through their APIKey, how many URL they can create or access in a certain time.
>
> **Database:**
>
> > - SQL VS NonSQL
> >
> >   >  Since we are likely going to store billions of rows and we don’t need to use relationships between objects – a NoSQL key-value store like Dynamo or Cassandra is a betterchoice, which would also be easier to scale.
> >
> > - Schema
> >
> >   - user
> >
> >     > user_id: int PK
> >     >
> >     > user_name: varcher(50)
> >     >
> >     > email: varcher(50)
> >
> >   - url
> >
> >     > tiny_url: varchar(20) PK
> >     >
> >     > original_url: varcher(500) 
> >     >
> >     > expire_data: datatime 
> >
> >   - map(no join in nosql server)
> >
> >     > tiny_url: varchar(20) PK
> >     >
> >     > user_id: int 
>
> **Component Detail Design:**
>
> > 1. Encoding original url to tiny url
> >
> > > - **Option1**: user MD5, and only pick last of first 6 charters
> > >
> > >   - Pro: fast
> > >   - con: hash collisions, can not guartee unique
> > >
> > > - **Option2**: Sequential id  + base36 ([a-z ,0-9]) or base62 ([A-Z, a-z, 0-9]), if we add ‘-’ and ‘.’, we can use base64 encoding
> > >
> > >   > **Question1:** 
> > >   >
> > >   > We have the following couple of problems with our encoding scheme:
> > >   >
> > >   > 1. If multiple users enter the same URL, they can get the same shortened URL, which is not acceptable?
> > >   >
> > >   > 2. What if parts of the URL are URL-encoded? e.g., http://distributed.php?id=design, and http://distributed.php%3Fid%3Ddesign are identical except for the URL encoding
> > >   >
> > >   > **Solution:** 
> > >   >
> > >   > 1. use the Sql DB  auto incretement id feature
> > >   > 2. use the userId append to the input URLs, if user not sign in , might be a problem.
> > >
> > > - **Option3: **Generating keys offline(KGS).  
> > >   We can have a standalone Key Generation Service (KGS) that generates random six letter strings beforehand and stores them in a database (let’s call it key-DB). Whenever we want to shorten a URL, we will just take one of the already generated keys and use it. This approach will make things quite simple and fast since we will not be encoding the URL or worrying about duplications or collisions.
> > >
> > >   > **Question1:**
> > >   >
> > >   > Can concurrency cause problems?
> > >   >
> > >   > **Solution:**
> > >   >
> > >   > 1. Two tables, one for not used key, another for used key. If key is ued, moved it; Or, use flag to show key is used or not
> > >   > 2. Cache some unused key in memory, and mark them as used
> > >   > 3. Distributed lock if we have multiple web server
> > >
> > >   > **Question2:****
> > >   >
> > >   > Isn’t KGS the single point of failure?
> > >   >
> > >   > **Solution:**
> > >   >
> > >   > we can have a standby replica of KGS, and whenever the primary server dies, it can take over to generate and provide keys.
> > >
> > >   > **Question3:**
> > >   >
> > >   > user redirection use 301 or 302?
> > >   >
> > >   > **Solution**
> > >   >
> > >   > use 302. 用户第一次访问某个短链接后，如果服务器返回301状态码，则这个用户在后续多次访问统一短链接，浏览器会直接请求跳转地址，而不是短链接地址，这样一来服务器端就无法收到用户的请求。
> > >   >
> > >   > 如果服务器返回302状态码，且告知浏览器不缓存短链接请求，那么用户每次访问短链接，都会先去短链接服务端取回长链接地址，然后在跳转。
> > >   >
> > >   > 1. 从语义上来说，301跳转更为合适，因为是永久跳转，不会每次都访问服务端，还可以减小服务端压力。
> > >   > 2. 但如果使用301跳转，服务端就无法精确搜集用户的访问行为了。
> > >   > 3. 相反302跳转会导致服务端压力增大，但服务端此时就可精确搜集用户的访问行为。基于用户的访问行为，可以做一些分析，得出一些有意思的结论。比如可以根据用户IP地址得出用户区域分布情况，根据User-Agent消息头分析出用户使用不同的操作系统以及浏览器比例等等。
>
> **Scalability**
>
> > 1. **DB**
> >
> >    - Sharing
> >      - **Range Based Partitioning: **We can store **tiny URLs** in separate partitions based on the first letter of the URL or the hash key. Hence we save all the URLs starting with letter ‘A’ in one partition and those that start with letter ‘B’ into another partition and so on. This approach is called range based partitioning.   **May cause some overload partitions **, need to Monitor it or use consistanc hashing.
> >      - **Hash Function: **In our case, we can take the hash of the ‘key’ or the actual URL to determine the partition to store the file. **May cause some overload partitions **.
> >
> >    - **Replica**
> >
> >      > KGS can have read/write spliting, once write server is done, use read server as master
> >      >
> >    
> > 2. **Cache**
> >
> >    > - **Where we use**:
> >    >
> >    >   >  Use cache between app server and db, app server and kgs.
> >    >
> >    > - **How much we need**
> >    >
> >    >   > As estimated above we need 200GB memory to cache 20% of daily traffic since a modern day server can have 256GB memory, we can easily fit all the cache into one machine, or we can choose to use a couple of smaller servers to store all these hot URLs.
> >    >
> >    > - **Cache policy**
> >    >
> >    >   > Read-through
> >    >   > Write-through
> >    >
> >    > - **Cache eviction policy**
> >    >
> >    >   > Least Recently Used (LRU) can be a reasonable policy for our system. 
> >    >   
> >    > - **Cache replica**
> >    >
> >    >   > When we can not find url, we will go to the db. database. Whenever this happens, we can update the cache and pass the new entry to all the cache replicas. Each replica can update their cache by adding the new entry. If a replica already has that entry, it can simply ignore it.
> >    >
> >
> > 3. **Load Balancer (LB)**
> >
> >    > - **Where we use**:
> >    >
> >    >   > 1. Between Clients and Application servers
> >    >   > 2. Between Application Servers and database servers
> >    >   > 3. Between Application Servers and Cache servers
> >    >
> >    > - **Distribution strategy**
> >    >
> >    >   > 1. Round-robin
> >    >   > 2. **least_conn**, use this one to avoid case that If a server is overloaded or slow
> >
>

### 2. 

