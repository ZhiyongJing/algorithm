### L5 系统设计

> 1. 面试官把题目说出来以后，问问题，搞清楚需求。需求就分两种：functional requirements 和 non-functional requirements。对于functional req，要根据题目适当地问问题，了解需求。对于non-functional req，基本就是在以下的需求里面挑选出合适的：usage pattern（是read heavy还是write heavy），是否需要考虑scalability的问题，是否需要highly available，consistency（strong consistency，还是eventual consistency，是否需要read-your-own-write consistency），latency是否有要求，data durability是否有要求，idempotency（对于付款相关的系统一定强调这个）。以上有那么多non-functional req，我们不可能对于每个问题都把每个需求说一遍，那样太浪费时间。我们应该关注这个系统的重点，比如让你设计monitoring system，那availability就是重中之重，其他的点比如scalability，虽然重要，但不会是考察的重点，可以这时候简单提一下，在面试的后期再回头讲解如何解决这个问题。functional requirements 和 non-functional requirements应该力求在15分钟以内说完。有些点快速略过很重要，有时候你说的不是重点，虽然说了不会扣分，但是会耽误几十秒时间，使得后面没有时间说重点。系统设计面试，时间管理非常重要。
>      在搞清楚需求之后，对于senior面试者，一般都是希望你从这里开始一直主导对话直到结束的。所以我会直接说"okay now let me list a few topics that we wanna cover"，然后直接写下"API design", "capacity estimation", "high-level architecture design"，"database (schema, sql/nosql, sharding, replication)"和"other topics"。这些就是系统设计可能会讨论的大方面，提前写好可以保证你在主导对话的同时记得涵盖所有的点，不然自己一直说，可能一兴奋忘了说重点。列出这些点之后我会说"now let's start with API design, what do you think?"然后面试官就会回答好或者不好，你就可以继续说下去了。这里要注意的是，我们其实只是在假装"drive the conversation"，最后先说哪个再说哪个其实还是面试官决定的，除非在少数情况下面试官没有偏好，告诉你先说哪个都行，那你就可以自己随便挑。注意，如果面试官让你自己挑顺序，你也要按照合理的顺序，或者让自己最舒服的顺序，来最大化自己的收益。下面具体说说买个方面应该怎么应对。
>
> 2. API design。如果这个系统会暴露出一些API，那么一般这是个考察重点。在说这个主题的时候，一般都是对于每个API，定好名字，定好输入是哪些，输出是哪些就行了。有少数情况面试官会问你是用RPC还是Rest API，有的还会问一些Rest API的知识，这些都准备一下就行了。有的情况下设计synchronized API和asynchronized API会有很大不同，那么就要说清楚你选择哪个，以及理由是什么：比如有的时候一个操作需要执行很久，这时候一般选择设计一个async API先立刻返回一个id给caller，让caller拿着id去查询操作的执行情况，而不应该只设计一个sync API让caller一直阻塞在那里。有时候一些API看起来是读东西的，所以不需要任何输入，这时候需要注意，就算不需要任何输入，也需要一个id来识别caller，因为有时候要做rate limiting，这个在面试的时候随便提一下就可以了，真正如何做rate limiting可以放在最后"other topics"里面说。
>
> 3. Capacity estimation。这个简单，grokking里面讲得不错了。一般就是把QPS (read, write)，network bandwidth(upload, download)，disk storage算一下就行了。注意，算QPS和bandwidth的时候，要把average value和peak value都算一下，一般是先算average，然后你可以说假设peak比average高一个数量级。1M/day换算成QPS就是12/s，这个要记住。算disk storage的时候，直接说“假设我们存5年的数据”，因为5年约等于2000天，好算，同时不要忘记存在disk上的数据都有replication，一般直接说"let's assume the replication factor is 3"，然后乘以3就行了。
>
> 4. High-level architecture design。这个就是画图，没啥好说的。建议提前熟悉一下面试要用的画图软件。
>
> 5. Database (schema, sql/nosql, sharding, replication)。一般讨论数据库的时候就是讨论这些点，说schema的时候一般说一下有哪些表，每张表有哪些column，谁是primary key就行了。对于sql/nosql，要根据场景来说，我遇到的只能用sql的场景很少，只能用nosql的场景也不多，一般都是二者都可以，但是我会跟面试官说虽然二者都可以，但我更偏向于nosql，因为这里写操作比较多。但是大家还是要根据具体情况来，比如订票系统，牵扯到多张表的distributed transaction，那么只能是sql，还有购物相关的系统，user-order-item这些东西是天生relational的，那么sql也是更好的选择。我印象中的其他系统就很少遇到那种只能用sql的。对于sharding，一般都有一个"shard by user id"还是"shard by item id"的trade off，如果是user id，那么会有Hotspotting问题（因为有的user特别活跃），如果是item id，虽然可以解决hotspotting问题，但是如果需要读某个user的数据，就需要访问所有的shard。这个trade off对于大多数题目都适用，如果是你在讲database的时候主动提出，会大大加分。
>
> 6. Other topics（cache/how to scale/push vs. pull/monitoring/rate limiting/failure handling/logging）。如果以上所有东西说完还有时间，一般面试官会让你在这里面挑一两个点讲一讲，就挑最拿手的讲就行了。注意，有时候这里面的某个点会是这个系统的重点，那么就应该把这个点放在前面着重讲。
>
> 以上就是我总结出来的套路，但是一定要注意在面试的时候根据面试官风格的不同适当调整。技巧就是每次都先问问面试官是不是ok，比如"let's start with capacity estimation, what do you think?"，有的面试官压根就不希望你做capacity estimation，会告诉你先不要做，后面有时间再做，那么这个技巧就可以帮你节省大量的时间。有时候有的面试官自己有强烈的偏好，会告诉你先画high-level architecture，然后等你画完不给你机会自己说，而是开始问问题，不给你机会drive the conversation。我面了这么多家，各种风格的面试官都遇到过，最后得出来的体会是：这个套路可以应付大多数面试，但是一但发现面试官有自己的偏好，就一定要放弃套路，跟着面试官走，有的面试官完全不需要你来drive conversation，你就让他问问题就好了。有的面试官在你说话的时候绝对不会打断，所以你要不断确认你说的是否合理，不然花很多时间说一些面试官根本不在乎的东西，虽然不扣分，但是浪费了宝贵的时间。对于大多数传统的面试官，根据这个套路就能应付。
>
> 面试技巧固然重要，内功也不能忽视。我在准备阶段主要接触了以下资料：
>
> 1. DDIA：这是我一开始准备就开始看的书，我觉得有条件的应该看两遍，开始的时候看一遍，然后进行一些面试练习之后再看一遍加深印象
> 2.  grokking：这是我看完书之后就看的资料。很多人说这个资料不行，但是我觉得这取决于你如何对待它。它的问题在于讲东西的时候有时候没有章法，很多时候没有列出重要的trade off。但是它的价值在于给我们准备了很多常考的例题，每个例题都踩了一些点。如果我们能合理组织它踩的这些点，还是可以应付面试的。最大的价值还是它提供的例题，基本都是面试中常见的题型。
> 3. YouTube上的InfoQ频道：看这个频道里的QCon视频，可以真正了解工业界对某些问题的解法是什么样的。看多了之后会增加你在面试的时候的自信：因为你知道你说的就是工业界常用的解法，绝对不会错。这个建议没事就看看，像看剧一样刷。
> 4. YouTube上Scott Shi的频道：这个频道最大的意义也是给大家提供了一些常见的例题（还有一些不常见的例题）。如果纯看视频里讨论的质量，肯定没有那么高，但是关键在于这些例题以及这些讨论能不能引发你的讨论，你能不能把这些题目自己模拟做一遍。
>
> 如果以上的资料都看完了，后面的重点就是练习面试技巧，我采取的是付费模拟面试的方法，大家可以采取别的方法。重点是一定要实战练习，让自己习惯面试的环境。

### L6 系统设计

> 3年前我准备跳槽的时候，基本在工作中没有积累系统设计的经验（因为不是做infra/backend的），也对系统设计面试毫无了解。当时为了准备系统设计面试，看了很多资料，总结了很多套路（细节都在【跳槽拿了7个senior offer，分享一下经验】这篇文章里），同时花了一千多刀做了付费模拟面试，最后保持了很好的面试成功率。
>
>
> 3年过去了，我这次并没有花很多时间准备系统设计面试，因为知识性的东西我在3年前都学过了，这次只需要复习就行了。对比3年前，我的主要进步在于思维方式的提升。过去3年的工作让我经历了大量系统设计实战，实战确实让我获得了更多系统设计知识，但是我觉得更重要的（也是能让我跨过L6这道坎的）是从实战中获得的思维方式的提升。
>
>
> 因此，这篇文章的中心思想就是：如果想把系统设计面试水平从L5提高到L6，不仅需要知识的积累，更需要思维方式的提升，最后还需要一点面试技巧的加持。延伸出去：思维方式的提升不仅是在系统设计上跨过L6这道坎的重要因素，（我认为）也是在公司内部升6的重要因素。
>
> **系统设计——知识**
>
> 系统设计知识不是这篇文章的重点，大家随便一搜“如何准备系统设计”，基本上出来的文章都讲得很好了。那些文章主要讲了如何学习系统设计的知识，但是对思维方式以及面试技巧的讲解不足。
>
> 关于获取系统设计知识：如果你在工作中能接触到系统设计实战，那么这是很好的学习系统设计知识的机会。但是很多人都没办法在工作中很好地接触系统设计实践，原因有：
> 	* 你可能做的不是backend/infra相关工作。比如你如果在大厂产品组，你的工作难度都在搞清产品需求以及开会对齐上面了,你的目标主要是drive business metric，所以你参与的系统设计的机会不多，而且写代码也主要是写业务逻辑。当然，这里只是举例，不同产品组差别还是很大的。
>  * 你可能在维护一个很老的系统，你的主要工作是让系统持续稳定运行，而不是加新功能。
>    你可能在参与开发一个新系统，但是系统复杂度不够（或者复杂的活都给别人干了），导致你只能参与边角料模块的设计。
>
> 以上主要是说，从工作中获取系统设计知识很难。现实中，每个人的工作都包含大量杂活，导致很难有人能有50%以上的工作时间花在“学知识”（比如系统设计实践）之类的事情上。实际上，如果你的工作有30%的时间花在这类事情上，我觉得就已经很难得了。
>
> 但是从工作中习得的系统设计知识也是最宝贵的，因为只有实战经验才能让你内化（internalize）这些知识。从书本上学习的知识，如果不加以练习以及运用，是很容易忘记的。对于没办法从工作中获得很多系统设计知识的人，如果你想准备系统设计面试，以下是我在当前这个时间（2024年3月）推荐的阅读资料（我的推荐不一定适合所有人，请同时也参考别人的文章）：
>
> * 内功：Designing Data-Intensive Applications
>   这本书里的内容基本上你不会在面试中直接用到，但是它讲了很多技术的理论基础。对于理论来说，这本书讲得很浅（很多理论都是一笔带过）。但是对于面试来说，这本书是很偏理论的。
> * 知识以及面试技巧：Alex Xu的ByteByteGo这个网站把系统设计面试所有常见题型都罗列了，并且对知识的讲解到了很细的层面（结合DDIA的阅读，会更好理解这里的知识）。
>   它对思维方式和面试技巧的讲解很浅，但是如果你毫无面试经验，还是可以学到很多的。
>   如果你没有很多时间准备面试，你甚至可以跳过DDIA直接学习这个网站。这样应该足够应付基础的系统设计面试。
>
> **系统设计——思维方式**
>
> 最近我一直在思考，在知识没有增长很多的情况下，是什么让我可以比3年前通过更高一级的系统设计面试，其实原因是很复杂的。我把这些因素抽象出来一个词，叫“思维方式”，因为我找不出其他更好的词了。由于这些因素的复杂性，我没办法很好地用几句话解释“什么是让你能通过L6系统设计面试的思维方式”。下面我会尝试从不同角度解读“思维方式”的意思，看看能不能让大家理解我在说什么。最后我会给出一些例子说明如何使用这些思维方式。如果你写作能力比我好，欢迎你帮我优化一下我的文章。
>
> 1）思维的高度、广度和深度
>
> L6在面试中当然要表现出比L5强的思维高度、广度和深度。在分析问题的时候，能不能后退一步，提炼出问题的核心；在谈到系统核心问题的时候，能不能深挖一层；在做重要决策的时候，能不能尽可能考虑更多的不同方案并且比较他们的优劣，L6在这些方面都应该做得更好。
>
> 2）少做假设，多和面试官确认
>
> 有时候我们会在面试中不自觉地对系统的关键部分做出假设。做假设当然是很重要的，特别是对于不重要的细枝末节，我们可以做出假设然后跳过。但是我们有可能会在关键的系统细节上做出一些错误假设，如果你这样做了并且没有和面试官确认，可能导致严重的后果（比如花大量时间解决了一个错误的问题）。.--
> . From 1point 3acres bbs
> 3）第一性原理思考（First Principle Thinking）
>
> 有时候系统里的细节太多，可能会导致我们的思维被淹没在各种细节里面，导致在全局性的问题上没法做出最好的决策。有时候多问几个简单的问题，比如“我们最终要解决的问题到底是啥”以及“当前的系统到底解决了这个问题没”，可能会有意想不到的效果。
>
> 4）软件工程思维
>
> 除去以上几点，还有一些思维方式，它们来自于人在复杂系统中工作的经验。能在面试中展现这些思维也是L6的一个重要信号。比如：
>
> * 尽量保持系统的简单性：如果你需要在已有系统重引入一个新的服务来完成你的设计，一定要思考“新的服务给系统带来了什么样的复杂度”，“增加的复杂度是否是值得的”，能在面试中合理阐述这些是L6的要求。
> * 考虑系统的扩展性，可维护性和可debug性：系统设计不是一次性的任务，现实中的系统都是需要不断发展的。你在设计系统的时候，能不能考虑到未来可能会增加什么样的需求，从而保持扩展性，以及考虑到工程师在维护和debug方面的难度，从而做出合理取舍，都很重要。
> * 很多问题不是二元的：很多时候我们在比较不同方案优劣的时候，不一定是二者取一。有时候可能是结合二者，有的时候可能是先选一个方案，然后等系统发展了（比如流量上来了）再迁移到另一套方案。能有这种思维方式也是L6的要求。
>
> 以上是我举的例子，软件工程思维肯定不止这些。如果用一句话总结，就是：这些思维方式，展现了你在复杂软件系统中工作的经验以及思考。
>
> **举例**
>
> 下面举几个例子说明如何在面试中展现出这些L6的思维方式。都是我各人的观点，不一定成熟，欢迎探讨。
>
> 例子1：思维的高度.--
>
> 系统设计面试有一类常见题目，我称其为“数数类题目”。一般题目的要求是：
>
> * 有一堆events源源不断流入我们的系统，流量很大
> * 我们需要设计一个系统aggregate这些events，支持用户查询
> * 比如ad click event，需要支持用户的查询例如number of clicks in each minute given an ad_id（ByteByteGo 例题）
>
> 前面的部分（pre-processing, pre-aggregation）不说，我直接开始说最后的部分：数据的存储和查询。一个常见的解法是：用一个数据库存每分钟的每个ad_id的click次数，然后做一个查询服务器，每次用户发查询的需求，就让服务器发请求给数据库，然后还可以讨论是否把数据cache在查询服务器的内存里面。我这里的意思不是这个解法有问题，相反，如果能把这个解法完整讲下来，大概率能过L5（甚至L6）的面试。
>
> 现在我用以上的例子讲解，我觉得可以如何将思维拔高一层：
>
> * 我们这里有两个本质的需求：查询和存储。
> * 查询：需要让用户以低latency查询number of clicks in each minute given an ad_id
> * 存储：数据需要被存在disk这种介质上（不能只存memory）
> * 数据库+cache的方案当然可以满足以上两种需求，但是in-memory KV store+[snapshot+WAL]也有可能满足以上两种需求
> * 如果是in-memory KV store+[snapshot+WAL]的设计，在数据来的时候不需要写数据库，直接插入in-memory KV store，同时在硬盘写入一条write-ahead-log（WAL），每隔一段时间把KV store的snapshot存到硬盘，用snapshot+WAL的方法保证in-memory KV store可以在死机以后可以恢复（这个固定套路在DDIA里面有深入讲解）。用这种方案，在查询的时候不需要另外的cache，因为in-memory KV store本身查询就很快，同时也有跟数据库一样的数据durability。当然，这种方案不具备数据库带来的各种特性（比如range scan），所以要根据具体的题目要求具体讨论。
> * 这里我不是在尝试比较这两个方案的优劣，我是在说明这种思维方式。可能我举的例子不是很好，可能这道题多数情况下就应该是数据库+cache。但是如果每次遇到“存储+查询”的问题你都只能想到“数据库+cache”，这是思维高度和宽度不够的表现，要多“退一步思考”想想我们真正要的是什么。或者我们也可以认为这是利用了“第一性原理”，“存储+查询”就是“存储+查询”，而不要一想到存储就是数据库，一想到查询就是cache。如果一个人在面试中充分理解需求的情况下，能合理比较这两个方案的优劣，我觉得这是L6的signal。
>   . 1point3acres.com
>
> 例子2：保持系统的简单性
>
> 跟上面的问题类似，我们把需求略微改动一下：进入我们系统的是每个用户的分数，需要我们显示的是一个global user ranking table。跟上面问题的核心区别：global ranking table是对所有用户都一样的东西（上面的问题里面，每个人有不同的ad_id）。假设我们选取了数据库+cache的设计，用数据库存用户分数，然后放进cache里面（这里cache是必须的，因为每个人查询的query都一样，如果没有cache，每个人的查询都hit数据库，非常不合理），很自然地我们会有两种更新cache的方法：
>
> * 方法一（pull）：让cache所在的服务器每隔一段时间从数据库里面拉取数据，然后更新cache。
> * 方法二（push）：在数据插入数据库的时候，同时也发送一个备份到cache所在的服务器，这样就不用从数据库里面拉取数据，数据也会更新鲜（因为每隔一段时间拉取，总是有延迟）。
> * 这里我不是在绝对地说两个方法的优劣，我的意思是：方法二有一个很大的劣势，如果不提出来就不能公平地比较两个方法。这个劣势就是：增加了系统复杂性。如果需要某个服务在插入数据库的同时把数据push到cache服务器，需要增加：
>   * Distributed transaction：“插入数据库”和“push到cache服务器”的操作必须同时成功或者失败，那么需要distributed transaction的支持，会给工程师开发增加复杂度。
>   * Dependency：本来这个服务只需要插入数据库，现在它还需要push数据到cache服务器，于是它跟cache服务器有了直接的dependency，增加了系统维护和scaling的难度。
>     Routing：如果你的cache服务器是按user_id sharded的，你还需要一个routing服务来告诉我“哪个user_id在哪个cache服务器”，从而我可以把数据正确地push到对的服务器。
> * 以上讨论的系统复杂度的增加，往往在面试中会被忽略。不仅是这道题，任何的push vs. pull的trade off都或多或少可以这样讨论。比如”Design Leetcode”题目里面，在用户提交了代码之后，到底是让客户端pull来拿代码运行结果，还是让服务器push结果给客户端（如果push结果给客户端，你需要增加一个服务，告诉我“哪个user_id跟哪个服务器连着”）。如果能在面试中合理地讨论某种方案增加的系统复杂性，我觉得是L6的signal。
>
>
> 例子3：问题不是二元的.
>
> 以”Design Leetcode”为例，假设我们采用了数据库的设计，数据库里面有一张表是存储submission的，每一行代表了某个用户对某个题目的一次提交。这张表里面肯定会有一行，需要存储用户提交的代码，很自然地有两种方法：
>
> * 方法一：把代码直接存在数据库。
> * 方法二：代码是一个text file，所以把文件存blob store，然后在数据库中存储一个url指向这个文件。
> * 这个问题不像”Design Instagram”里面那样绝对，因为”Design Instagram”的时候，照片是大概率不能存数据库的，需要存blob store。这也是这个问题有趣的地方，我会这样在面试中讨论：代码算是文件，但是它一般比较小，我觉得我们可以拿用户真实提交的代码做数据分析，如果他们确实都很小，我们可以设置一个limit，保证他们大小不超过某个值，然后全部存数据库。如果我们不得不支持一些大的代码文件，可以只把他们放blob store，其他的依然直接放数据库（hybrid 方法）。或者我们可以先把所有代码存数据库，保证初期开发维护简单（增加blob store会增加系统复杂度），等流量上来以后，数据库disk使用率增长太快，再迁移到blob store。
> * 以上的讨论，我主要坚持了“问题不是二元的”的思维方式：提到数据分析，是展示我知道什么时候做data driven decision；提到hybrid方法，展示了思维的灵活性，不是所有东西都二选一；提到先用简单方法再做migration，展示了软件工程的经验。当你能说到这个层面的时候，最后你给出什么答案也不重要了，这也回到了系统设计面试的目的：考察你的思维能力大过看你最后给出什么答案。
>
>
> 例子4：第一性原理思考
>
> 这里我不举系统设计题目的例子了，我举一个我刚编的例子：假设在你工作中，有个人写了个文档，展示自己优化了某个library，增加了某个系统（比如logging系统）将数据写到磁盘的throughput。一般人会开始看文档里面提到的各种细节，看这个人具体做了哪些优化，将throughput提高了多少倍。如果从第一性原理出发，我们可以这样看待这个问题：
>
> * 本质上你增加了磁盘写入的吞吐量，那么我先问这三个问题：这个磁盘的理论写入吞吐量上限是多少？之前的吞吐量达到了上限的百分之几？优化后达到了百分之几？
> * 这样，如果优化以后依然离上限很远（比如依然只有理论值的10%），你就能带着目的去看那个文档：他关注的优化点是哪些，是不是找到了所有的bottleneck，他有没有意识到他优化以后离理论上限还差很远。如果他不知道理论上限，这个优化的工作很可能是白干了（即使它优化了10倍），因为这人连fundamental metric都没考虑到，可能bottleneck根本不在这个library上。
> * 这个例子就是用第一性原理思考的例子：在大量细节面前，能不能找到根本问题，然后找到最重要的metric。
>
> **对思维方式的总结 **
>
> 通过以上阐述，相信大家可以或多或少知道我所说的“思维方式”指什么。明显可以看出来，这些能力主要从工作中获得，很难通过单纯地看书去学习。这些思维方式不仅可以让你在面试中有L6的表现，同时也能帮助你在现实中升6（有时间我可以写篇文章系统讲讲我理解的L6和L5在工作中的区别），虽然思维方式的提升只是6和5的区别之一。
>
> 无论大家当前是几级，做的工作具体是什么样，在工作中多思考总是能让自己收益的。如果能把以上的各种思维方式在工作中运用自如，L6的面试就不会很难。所以下面我做出一个主观的结论：
>
> * 如果你在工作中是L5，通过学习系统设计面试的知识性内容，可以通过L5的系统设计面试，就像3年前的我那样。但是如果想通过L6的系统设计面试，则要努力提升自己的思维方式。
> * 如果你在工作中是L6，那么大概率你已经基本拥有了L6的思维方式，那么你通过学习知识性的内容，结合自己已有的思维方式和面试技巧的打磨，是可以大概率通过L6的面试的。
> * 当然，真实世界是复杂的，有的人有6的水平却还呆在5，有的人升了6也不一定有很好的思维方式（或者有的职位的6不要求很好的思维方式）。
>
>
> **系统设计——面试技巧**
>
> 在掌握知识和思维方式的前提下，一定不能忽略面试技巧。面试毕竟跟平时的工作环境不一样，它要求你在45分钟（或者1小时）内展现出某个等级（比如L6）的水平，所以对于时间的合理分配是很重要的，这要求你极度抓大放小，准确找出核心的问题并多花时间讨论，同时对于非核心问题，一笔带过或者根本不提。看过ByteByteGo之后可能会有的副作用：它讲的细节太多了，可能让你误以为面试也需要讲得很细节，导致你所有东西都讲得很细，导致时间不够用；同时它对思路讲得不够高屋建瓴，导致你忽视了对思考过程的讲解，导致面试官无法从你的思考过程得到“你是L6”的信号。
>
>
> 我看了很多讲系统设计面试的文章，没有人能把面试技巧写得很好。这非常合理，因为面试技巧确实很难单纯用文字写下来。改进面试技巧最有效的方法就是找厉害的人帮你做模拟面试。
>
> 如果让我用一个词总结系统设计面试技巧，就是：灵活。兵无常势水无常形，系统设计确实有套路，但是过分照搬套路会有负面影响。举个过分照搬套路的例子，就是我自己3年前写的文章：跳槽拿了7个senior offer，分享一下经验。虽然我按照那个套路通过了L5的面试，但是它支撑不了L6的面试，所以我对新手的建议是：先学习套路，然后学习放弃套路。如何在套路和放弃套路之间找到平衡？例子：
>
> * 在面试官给出问题之后，一定要反问面试官问题，把题目的要求弄清楚，这是固定套路。但是具体问什么问题，一定要灵活，要只问当前问题的核心问题，比如让你设计一个monitoring系统，availability就很重要，一定要问，但是对于其他题目，availability往往不是最重要的指标，就尽量不要一开始讨论（除非是面试官主动提出，或者在讨论完其他核心问题后你觉得可以讨论）。
> * 在确定题目的要求之后，到底是先做API Design，High-level Design，Database Design，Back-of-the-envelope Estimation，还是先做其他的，都没有固定套路，应该根据题目找出你认为当前最重要的话题。“找出当前最重要的话题”也是系统设计考察的重要能力，如果一个面试者总是没办法自己独立找到当前最重要的话题，那肯定是过不了L6的面试的。
> * 知道什么时候dive deep，知道什么时候一笔带过。很多面试者喜欢只对自己熟悉的领域dive deep，却对其他领域一笔带过。面试中要尽量对核心领域（对整个设计有重大影响）多讨论，对其他领域少讨论，当然，“能独立找出当前设计的核心领域”也是面试考察的重点。
> * 对系统的failure recovery和scalability很了解。这个是固定套路了。对于大多数题目，当你把该说的都说了以后，总是可以看看这两个话题有没有涵盖：每一个服务，有没有都做到能recover from failure，以及是否scalable。

